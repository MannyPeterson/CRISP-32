/**
 * @file main.c
 * @brief CRISP-32 Virtual Machine Test Harness and Example Usage
 * @author Manny Peterson <manny@manny.ca>
 * @date 2025
 * @copyright Copyright (C) 2025 Manny Peterson
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

#include "c32_vm.h"
#include "c32_string.h"

/* Include embedded test programs */
#include "../tests/simple.h"
#include "../tests/hello.h"

/**
 * @defgroup test_harness Test Harness
 * @brief Example usage and test programs for CRISP-32 VM
 *
 * This module demonstrates how to use the CRISP-32 virtual machine
 * by loading and executing test programs. The test programs are
 * embedded as C arrays generated by the bin2h tool.
 * @{
 */

/** @brief Test program memory buffer (64KB) */
static uint8_t test_memory[65536];

/**
 * @brief Simple instruction disassembler for debugging
 *
 * Decodes and prints instruction information for debugging purposes.
 * Currently a stub implementation that extracts instruction fields
 * but does not print them.
 *
 * @param addr Address of instruction in memory
 * @param inst Pointer to 8-byte instruction
 *
 * @note This is a placeholder for future disassembler functionality
 */
static void dump_instruction(uint32_t addr, const uint8_t *inst) {
    uint8_t opcode = inst[0];
    uint8_t rs = inst[1];
    uint8_t rt = inst[2];
    uint8_t rd = inst[3];
    uint32_t imm = c32_read_word(inst + 4);

    /* Print address and raw bytes */
    {
        int i;
        for (i = 0; i < 8; i++) {
            /* Placeholder to use variables */
            (void)opcode;
            (void)rs;
            (void)rt;
            (void)rd;
            (void)imm;
            (void)addr;
        }
    }

    /* TODO: Decode and print instruction mnemonic */
}

/**
 * @brief Load a test program into VM memory
 *
 * Copies a test program from the embedded array into VM guest memory
 * at the specified load address. Performs bounds checking to ensure
 * the program fits within the VM's memory.
 *
 * @param vm Pointer to VM structure
 * @param program Pointer to program binary data
 * @param size Size of program in bytes
 * @param load_addr Address in VM memory to load program
 */
static void load_program(c32_vm_t *vm, const uint8_t *program, uint32_t size, uint32_t load_addr) {
    if (load_addr + size <= vm->memory_size) {
        c32_memcpy(vm->memory + load_addr, program, size);
    }
}

/**
 * @brief Run embedded test programs
 *
 * Executes two test programs to verify VM functionality:
 *
 * Test 1: Simple arithmetic program
 * - Loads test_simple program at address 0x1000
 * - Executes: ADDI R1, R0, 42; ADDI R2, R0, 10; ADD R3, R1, R2; SYSCALL
 * - Verifies results: R1 = 42, R2 = 10, R3 = 52
 *
 * Test 2: Hello program
 * - Loads test_hello program at address 0x1000
 * - Verifies program loads correctly
 * - Dumps first few instructions for debugging
 *
 * @return 0 on success, -1 on failure
 */
static int run_tests(void) {
    c32_vm_t vm;
    uint32_t i;
    int steps;

    /* Test 1: Load and execute simple program */
    c32_vm_init(&vm, test_memory, sizeof(test_memory));
    load_program(&vm, test_simple, test_simple_size, 0x1000);

    /* Verify first instruction loaded correctly */
    if (vm.memory[0x1000] != 0x05) {
        return -1;  /* Failed */
    }

    /* Set PC to start of program and run */
    vm.pc = 0x1000;
    vm.running = 1;

    /* Execute instructions (max 100 steps to prevent infinite loops) */
    for (steps = 0; steps < 100 && vm.running; steps++) {
        if (c32_vm_step(&vm) != 0) {
            break;
        }
    }

    /* Simple program should: ADDI R1, R0, 42; ADDI R2, R0, 10; ADD R3, R1, R2 */
    /* Result: R1 = 42, R2 = 10, R3 = 52 */
    if (vm.regs[1] != 42 || vm.regs[2] != 10 || vm.regs[3] != 52) {
        return -1;  /* Test failed */
    }

    /* Test 2: Load hello program */
    c32_vm_init(&vm, test_memory, sizeof(test_memory));
    load_program(&vm, test_hello, test_hello_size, 0x1000);

    /* Verify program loaded */
    if (vm.memory[0x1000] != 0x05) {
        return -1;  /* Failed */
    }

    /* Dump first few instructions for verification */
    for (i = 0; i < 3 && i * 8 < test_hello_size; i++) {
        dump_instruction(0x1000 + i * 8, &vm.memory[0x1000 + i * 8]);
    }

    return 0;  /* Success */
}

/**
 * @brief Main entry point
 *
 * Initializes the VM and runs the embedded test programs.
 * Returns 0 on success, -1 on failure.
 *
 * @return Exit code (0 = success, -1 = failure)
 */
int main(void) {
    int result;

    /* Run embedded tests */
    result = run_tests();

    /* For now, just run tests and exit */
    /* TODO: Implement instruction execution */
    /* TODO: Implement proper test reporting */

    return result;
}

/** @} */ /* end of test_harness */
